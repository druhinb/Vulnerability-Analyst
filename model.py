"""
NVD Vulnerability Analysis Chatbot
--------------------------------
A professional-grade CLI tool for querying the National Vulnerability Database (NVD) 
using LangChain ReACT Agents. Supports both OpenAI and local inference via LlamaCpp.
Local models are a little broken, so I recommend using an OpenAI model

Features:
- Flexible model support (OpenAI GPT-4, local LLaMA.cpp models)
- Structured vulnerability information
- Web content fetching for reference links
- Memory-aware conversation handling

Requirements:
- OPENAI_API_KEY: OpenAI API key 
- NVD_API_KEY: National Vulnerability Database API key

Usage:
$ python model.py 

Author: Druhin Bhowal
"""

import os
import sys
import logging
import argparse
import re
import time
from pathlib import Path
from typing import List, Optional
from functools import wraps
from urllib.parse import urlparse

import requests
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.theme import Theme
from pydantic import BaseModel, Field, field_validator
from dotenv import load_dotenv
from bs4 import BeautifulSoup

from huggingface_hub import hf_hub_download
from langchain.agents import Tool, AgentExecutor, create_react_agent
from langchain.memory import ConversationBufferWindowMemory
from langchain.prompts import PromptTemplate
from langchain_core.language_models.base import BaseLanguageModel
from langchain_community.chat_models import ChatLlamaCpp
from langchain_openai.chat_models import ChatOpenAI


# Configuration
class Config:
    """Application configuration constants and environment settings.

    This class encapsulates constants and environment settings for the
    application. It provides a single source of truth for application
    configuration.

    Attributes:
        NVD_API_BASE_URL (str): The base URL for the NVD API.
        MODELS_CACHE_DIR (Path): The directory where models are cached.
        DEFAULT_TIMEOUT (int): The default timeout for API requests.
        MAX_RETRIES (int): The maximum number of retries for API requests.
        MEMORY_WINDOW_SIZE (int): The size of the memory window for the chatbot.
    """

    NVD_API_BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    MODELS_CACHE_DIR = Path.home() / ".cache" / "nvd-chatbot" / "models"
    DEFAULT_TIMEOUT = 30
    MAX_RETRIES = 3
    MEMORY_WINDOW_SIZE = 3

    @classmethod
    def setup(cls):
        """Initialize application configuration."""
        load_dotenv()
        cls.MODELS_CACHE_DIR.mkdir(parents=True, exist_ok=True)
        return cls


# Logging Configuration
def setup_logging(log_file: str = "nvd_chatbot.log") -> logging.Logger:
    """Configure application logging with both file and console handlers."""
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[logging.FileHandler(log_file)],
    )
    return logging.getLogger(__name__)


# Domain Models
class CVSSMetrics(BaseModel):
    """CVSS vulnerability metrics."""

    base_score: float = Field(default=0.0, ge=0.0, le=10.0)
    vector_string: str = Field(default="N/A")

    @field_validator("base_score")
    def validate_score(cls, v):
        if not 0 <= v <= 10:
            raise ValueError("CVSS score must be between 0 and 10")
        return v


class CVEDetails(BaseModel):
    """Holds the most important CVE information"""

    cve_id: str = Field(description="The CVE identifier")
    severity: CVSSMetrics = Field(description="CVSS metrics")
    description: str = Field(description="Vulnerability description")
    references: List[str] = Field(description="List of reference URLs")
    published_date: str = Field(description="Date vulnerability was published")

    def format_output(self) -> str:
        """Format CVE details for display."""
        return f"""
        CVE ID: {self.cve_id}
        Severity Score: {self.severity.base_score}/10.0
        CVSS Vector: {self.severity.vector_string}
        Published Date: {self.published_date}

        Description:
        {self.description}

        References:
        {chr(10).join(f'- {ref}' for ref in self.references)}
        """


class SearchQuery(BaseModel):
    """Search parameters for vulnerability queries."""

    keywords: str = Field(description="Search keywords")
    max_results: int = Field(
        description="Maximum number of results to return", default=10, ge=1, le=100
    )


class LLMFactory:
    """Factory for creating language model instances."""

    @staticmethod
    def create_llm(model_spec: str, temperature: float) -> BaseLanguageModel:
        """Create an LLM instance based on the model specification."""
        if model_spec.startswith("openai"):
            return LLMFactory._create_openai_model(temperature)
        elif model_spec.startswith("local"):
            return LLMFactory._create_local_model(model_spec[6:], temperature)
        elif model_spec.startswith("hf"):
            return LLMFactory._create_huggingface_model(model_spec[3:], temperature)
        raise ValueError(f"Unsupported model specification: {model_spec}")

    @staticmethod
    def _create_openai_model(temperature: float) -> ChatOpenAI:
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise ValueError("OPENAI_API_KEY environment variable not set")
        return ChatOpenAI(
            model_name="gpt-4o-mini", temperature=temperature, openai_api_key=api_key
        )

    @staticmethod
    def _create_local_model(path: str, temperature: float) -> ChatLlamaCpp:
        if not os.path.exists(path):
            raise ValueError(f"Local model not found: {path}")
        return LLMFactory._configure_llama_cpp(path, temperature)

    @staticmethod
    def _create_huggingface_model(spec: str, temperature: float) -> ChatLlamaCpp:
        repo_id, filename = spec.rsplit("/", 1)
        model_path = hf_hub_download(repo_id, filename)
        return LLMFactory._configure_llama_cpp(model_path, temperature)

    @staticmethod
    def _configure_llama_cpp(model_path: str, temperature: float) -> ChatLlamaCpp:
        return ChatLlamaCpp(
            model_path=model_path,
            temperature=temperature,
            n_ctx=4092,
            max_tokens=512,
            streaming=True,
            verbose=False,
            n_gpu_layers=-1,
            gpu_layers=None,
        )


# NVD API Client
class NVDClient:
    """
    Client for interacting with the NVD API.

    This client provides methods to fetch details about specific CVEs and to search
    for vulnerabilities based on search queries. It handles API requests and
    parsing of the results into structured objects.
    """

    def __init__(
        self, api_key: Optional[str] = None, timeout: int = Config.DEFAULT_TIMEOUT
    ):
        self.api_key = api_key or os.getenv("NVD_API_KEY")
        self.timeout = timeout
        self.session = requests.Session()
        if self.api_key:
            self.session.headers.update({"apiKey": self.api_key})

    def get_cve_details(self, cve_id: str) -> CVEDetails:
        """Fetch and parse details for a specific CVE."""
        try:
            cve_id = re.sub(r"[^a-zA-Z0-9-]", "", cve_id)
            cve_id = cve_id.upper()
            response = self.session.get(
                Config.NVD_API_BASE_URL, params={"cveId": cve_id}, timeout=self.timeout
            )
            response.raise_for_status()
            data = response.json()
            vuln = data.get("vulnerabilities", [])
            if not vuln:
                raise ValueError(f"No details found for {cve_id}")

            return self._parse_vulnerability(vuln[0])

        except requests.exceptions.RequestException as e:
            raise ConnectionError(f"Failed to fetch CVE details: {str(e)}")

    def search_vulnerabilities(self, query: SearchQuery) -> List[CVEDetails]:
        """Search for vulnerabilities matching the given query."""
        try:
            query.keywords = re.sub(r"[^a-zA-Z0-9-]", "", query.keywords)
            response = self.session.get(
                Config.NVD_API_BASE_URL,
                params={
                    "keywordSearch": query.keywords,
                    "resultsPerPage": query.max_results,
                },
                timeout=self.timeout,
            )
            response.raise_for_status()
            data = response.json()

            return [
                self._parse_vulnerability(vuln)
                for vuln in data.get("vulnerabilities", [])
            ]

        except requests.exceptions.RequestException as e:
            raise ConnectionError(f"Failed to search vulnerabilities: {str(e)}")

    @staticmethod
    def _parse_vulnerability(vuln_data: dict) -> CVEDetails:
        """Parse raw vulnerability data into a CVEDetails object."""
        cve = vuln_data["cve"]
        metrics = cve.get("metrics", {})
        cvss = metrics.get("cvssMetricV40", metrics.get("cvssMetricV31", {}))[0].get(
            "cvssData", {}
        )

        description = next(
            (
                desc["value"]
                for desc in cve.get("descriptions", [])
                if desc.get("lang") == "en"
            ),
            "No description available",
        )

        references = [
            ref.get("url") for ref in cve.get("references", []) if ref.get("url")
        ]

        return CVEDetails(
            cve_id=cve["id"],
            severity=CVSSMetrics(
                base_score=float(cvss.get("baseScore", cvss.get("impactScore", 0.0))),
                vector_string=cvss.get("vectorString", "N/A"),
            ),
            description=description,
            references=references,
            published_date=cve.get("published", "N/A"),
        )


class WebTools:
    """Tools for web content retrieval and processing."""

    @staticmethod
    def fetch_url_content(url: str, max_length: int = 2000) -> str:
        """Fetch and clean content from a URL."""
        try:
            # Validate URL
            parsed = urlparse(url)
            if not parsed.scheme or not parsed.netloc:
                return "Invalid URL provided"

            # Fetch content
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()

            # Parse HTML
            soup = BeautifulSoup(response.text, "html.parser")

            # Remove unwanted elements
            for element in soup(["script", "style", "nav", "footer", "header"]):
                element.decompose()

            # Extract text
            text = " ".join(soup.stripped_strings)

            # Truncate if needed
            if len(text) > max_length:
                text = text[:max_length] + "..."

            return text

        except requests.RequestException as e:
            return f"Error fetching URL: {str(e)}"
        except Exception as e:
            return f"Error processing URL content: {str(e)}"


# Chatbot Agent
class VulnerabilityAgent:
    """Agent that handles user queries about the database"""

    def __init__(
        self,
        llm: BaseLanguageModel,
        nvd_client: NVDClient,
        verbose: bool,
        memory_size: int = Config.MEMORY_WINDOW_SIZE,
    ):
        self.llm = llm
        self.nvd_client = nvd_client
        self.verbose = verbose
        self.web_tools = WebTools()
        self.memory = ConversationBufferWindowMemory(
            memory_key="chat_history", k=memory_size, return_messages=True
        )
        self.agent_executor = self._create_agent()

    def _create_agent(self) -> AgentExecutor:
        """Create the agent with appropriate tools and prompt."""
        tools = [
            Tool(
                name="Get CVE Details",
                func=self._get_cve_details,
                description="""Get details about a CVE ID. Useful for getting targeted information about one particular vulnerability. 
                Input must be in the format: CVE-XXXX-XXXX. For example: CVE-2022-12345.""",
            ),
            Tool(
                name="Search Vulnerabilities",
                func=self._search_vulnerabilities,
                description="Search vulnerabilities by keyword. Useful for getting a list of vulnerabilities that match a particular keyword.",
            ),
            Tool(
                name="Fetch URL Content",
                func=self.web_tools.fetch_url_content,
                description="""Fetch and extract content from a URL. Useful for getting additional information from reference links.
                Input should be a complete URL (e.g., https://example.com).""",
            ),
        ]
        self.llm.bind(stop=["\nFinal Answer:"])
        prompt = PromptTemplate(
            input_variables=[
                "tools",
                "tool_names",
                "chat_history",
                "input",
                "agent_scratchpad",
            ],
            template=self._get_prompt_template(),
        )
        agent = create_react_agent(self.llm, tools, prompt)
        return AgentExecutor(
            agent=agent,
            tools=tools,
            memory=self.memory,
            verbose=self.verbose,
            max_iterations=5,
            early_stopping_method="force",
            handle_parsing_errors=True,
        )

    def _get_cve_details(self, cve_id: str) -> str:
        """Get detailed information about a specific CVE from NVD."""
        try:
            details = self.nvd_client.get_cve_details(cve_id)
            return details.format_output()
        except Exception as e:
            return f"Error fetching CVE details: {str(e)}"

    def _search_vulnerabilities(self, query: str) -> str:
        """Search NVD for vulnerabilities matching the query."""
        try:
            search_query = SearchQuery(keywords=query)

            results = self.nvd_client.search_vulnerabilities(search_query)

            # If no results are found, return a message
            if not results:
                return f"No vulnerabilities found matching '{query}'"

            # Format the results into a string
            output = [f"Found {len(results)} vulnerabilities matching '{query}':"]
            for vuln in results:
                desc = vuln.description[:300]
                if len(vuln.description) > 300:
                    desc += "..."
                output.append(
                    f"{vuln.cve_id} (Severity: {vuln.severity.base_score}/10.0)\n{desc}"
                )

            # Return the formatted string
            return "\n\n".join(output)

        except Exception as e:
            return f"Error searching vulnerabilities: {str(e)}"

    @staticmethod
    def _get_prompt_template() -> str:
        """Get the prompt template for the agent."""

        return """You are a worldclass vulnerability and cybersecurity analyst. You have access to the National Vulnerability Database via 
        the following tools from the NVD API:

        {tools}
        
        Please do not repeat the loop more than 3 times. Make sure to give a final answer at the end of the 3 iterations.
        If you go on for any longer, you will be terminated.
        
        You MUST use the following format: 
        Question: the question asked by the USER that you must answer

        Thought: your thoughts on what next to do,
        Action: the action to take, should be one of [{tool_names}]
        Action Input: ONLY the input to the action
        Observation: the result of the action
        ... (this Thought/Action/Action Input/Observation can repeat ONLY UP TO 3 TIMES. DO NOT EXCEED THIS LIMIT.)
        Thought: I know the final answer, or I cannot answer the user's query because of lack of info.
        Final Answer: the final answer to the original input question, that answers the original
        question with any and all data that is provided.
        
        
        Begin!

        Previous conversation history:
        {chat_history}

        Question: {input}
        Thought: {agent_scratchpad}"""

    def process_input(self, user_input: str) -> str:
        """Process user input and return the agent's response."""
        try:
            response = self.agent_executor.invoke(
                {"input": user_input, "chat_history": self.memory.load_memory_variables}
            )
            return (
                response.get("output", "")
                if isinstance(response, dict)
                else str(response)
            )
        except Exception as e:
            return f"Error processing input: {str(e)}"


def main():
    """Main entry point for the application."""
    # Initialize Rich console with custom theme
    console = Console(
        theme=Theme(
            {
                "info": "cyan",
                "warning": "yellow",
                "error": "red bold",
                "success": "green bold",
            }
        )
    )

    # Create decorator for loading animations
    def with_loading(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=console,
                transient=True,
            ) as progress:
                task = progress.add_task(description="Processing...", total=None)
                return func(*args, **kwargs)

        return wrapper

    # Wrap agent's process_input with loading animation
    VulnerabilityAgent.process_input = with_loading(VulnerabilityAgent.process_input)

    # Start the application with style
    console.clear()
    console.print(
        Panel.fit(
            "[bold cyan]NVD Vulnerability Analysis Assistant[/bold cyan]\n"
            "[dim]By Druhin Bhowal[/dim]",
            border_style="blue",
            padding=(1, 2),
        )
    )

    try:
        parser = argparse.ArgumentParser()
        parser.add_argument("--model", type=str, default="openai")
        parser.add_argument("--temperature", type=float, default=0.3)
        parser.add_argument("--no-verbose", action="store_false")
        args = parser.parse_args()

        # Initialize with loading animation
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console,
            transient=True,
        ) as progress:
            task = progress.add_task(description="Initializing system...", total=None)
            config = Config.setup()
            logger = setup_logging()

            llm = LLMFactory.create_llm(args.model, args.temperature)
            nvd_client = NVDClient()
            agent = VulnerabilityAgent(llm, nvd_client, args.no_verbose)

        # Main interaction loop with fancy formatting
        while True:
            try:
                # Get user input with prompt
                user_input = console.input("\n[bold blue]You:[/bold blue] ").strip()

                if user_input.lower() in ["exit", "quit", "bye"]:
                    console.print("\n[bold cyan]Goodbye! 👋[/bold cyan]")
                    break

                # Process input and show response
                response = agent.process_input(user_input)

                console.print(
                    Panel(
                        response,
                        title="[bold green]Assistant[/bold green]",
                        border_style="green",
                        expand=False,
                        padding=(1, 2),
                    )
                )

            except KeyboardInterrupt:
                console.print("\n[yellow]Exiting...[/yellow]")
                break
            except Exception as e:
                console.print(f"\n[error]Error: {str(e)}[/error]")

    except Exception as e:
        console.print(f"\n[error]Fatal Error: {str(e)}[/error]")
        sys.exit(1)


if __name__ == "__main__":
    main()
